// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "q2profiling.hxx"

namespace q2profiling
{
  // FunctionType
  // 

  const FunctionType::metrics_type& FunctionType::
  metrics () const
  {
    return this->metrics_.get ();
  }

  FunctionType::metrics_type& FunctionType::
  metrics ()
  {
    return this->metrics_.get ();
  }

  void FunctionType::
  metrics (const metrics_type& x)
  {
    this->metrics_.set (x);
  }

  void FunctionType::
  metrics (::std::auto_ptr< metrics_type > x)
  {
    this->metrics_.set (x);
  }

  const FunctionType::statistics_type& FunctionType::
  statistics () const
  {
    return this->statistics_.get ();
  }

  FunctionType::statistics_type& FunctionType::
  statistics ()
  {
    return this->statistics_.get ();
  }

  void FunctionType::
  statistics (const statistics_type& x)
  {
    this->statistics_.set (x);
  }

  void FunctionType::
  statistics (::std::auto_ptr< statistics_type > x)
  {
    this->statistics_.set (x);
  }

  const FunctionType::name_type& FunctionType::
  name () const
  {
    return this->name_.get ();
  }

  FunctionType::name_type& FunctionType::
  name ()
  {
    return this->name_.get ();
  }

  void FunctionType::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void FunctionType::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }


  // MetricType
  // 

  const MetricType::name_type& MetricType::
  name () const
  {
    return this->name_.get ();
  }

  MetricType::name_type& MetricType::
  name ()
  {
    return this->name_.get ();
  }

  void MetricType::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void MetricType::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const MetricType::type_type& MetricType::
  type () const
  {
    return this->type_.get ();
  }

  MetricType::type_type& MetricType::
  type ()
  {
    return this->type_.get ();
  }

  void MetricType::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void MetricType::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }


  // MeasurementType
  // 

  const MeasurementType::unit_optional& MeasurementType::
  unit () const
  {
    return this->unit_;
  }

  MeasurementType::unit_optional& MeasurementType::
  unit ()
  {
    return this->unit_;
  }

  void MeasurementType::
  unit (const unit_type& x)
  {
    this->unit_.set (x);
  }

  void MeasurementType::
  unit (const unit_optional& x)
  {
    this->unit_ = x;
  }

  void MeasurementType::
  unit (::std::auto_ptr< unit_type > x)
  {
    this->unit_.set (x);
  }

  const MeasurementType::name_type& MeasurementType::
  name () const
  {
    return this->name_.get ();
  }

  MeasurementType::name_type& MeasurementType::
  name ()
  {
    return this->name_.get ();
  }

  void MeasurementType::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void MeasurementType::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const MeasurementType::type_type& MeasurementType::
  type () const
  {
    return this->type_.get ();
  }

  MeasurementType::type_type& MeasurementType::
  type ()
  {
    return this->type_.get ();
  }

  void MeasurementType::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void MeasurementType::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const MeasurementType::by_type& MeasurementType::
  by () const
  {
    return this->by_.get ();
  }

  MeasurementType::by_type& MeasurementType::
  by ()
  {
    return this->by_.get ();
  }

  void MeasurementType::
  by (const by_type& x)
  {
    this->by_.set (x);
  }

  void MeasurementType::
  by (::std::auto_ptr< by_type > x)
  {
    this->by_.set (x);
  }


  // ChannelType
  // 

  const ChannelType::UnMA_optional& ChannelType::
  UnMA () const
  {
    return this->UnMA_;
  }

  ChannelType::UnMA_optional& ChannelType::
  UnMA ()
  {
    return this->UnMA_;
  }

  void ChannelType::
  UnMA (const UnMA_type& x)
  {
    this->UnMA_.set (x);
  }

  void ChannelType::
  UnMA (const UnMA_optional& x)
  {
    this->UnMA_ = x;
  }

  const ChannelType::hUnMA_optional& ChannelType::
  hUnMA () const
  {
    return this->hUnMA_;
  }

  ChannelType::hUnMA_optional& ChannelType::
  hUnMA ()
  {
    return this->hUnMA_;
  }

  void ChannelType::
  hUnMA (const hUnMA_type& x)
  {
    this->hUnMA_.set (x);
  }

  void ChannelType::
  hUnMA (const hUnMA_optional& x)
  {
    this->hUnMA_ = x;
  }

  const ChannelType::bytes_optional& ChannelType::
  bytes () const
  {
    return this->bytes_;
  }

  ChannelType::bytes_optional& ChannelType::
  bytes ()
  {
    return this->bytes_;
  }

  void ChannelType::
  bytes (const bytes_type& x)
  {
    this->bytes_.set (x);
  }

  void ChannelType::
  bytes (const bytes_optional& x)
  {
    this->bytes_ = x;
  }

  const ChannelType::hBytes_optional& ChannelType::
  hBytes () const
  {
    return this->hBytes_;
  }

  ChannelType::hBytes_optional& ChannelType::
  hBytes ()
  {
    return this->hBytes_;
  }

  void ChannelType::
  hBytes (const hBytes_type& x)
  {
    this->hBytes_.set (x);
  }

  void ChannelType::
  hBytes (const hBytes_optional& x)
  {
    this->hBytes_ = x;
  }

  const ChannelType::Values_optional& ChannelType::
  Values () const
  {
    return this->Values_;
  }

  ChannelType::Values_optional& ChannelType::
  Values ()
  {
    return this->Values_;
  }

  void ChannelType::
  Values (const Values_type& x)
  {
    this->Values_.set (x);
  }

  void ChannelType::
  Values (const Values_optional& x)
  {
    this->Values_ = x;
  }

  const ChannelType::hValues_optional& ChannelType::
  hValues () const
  {
    return this->hValues_;
  }

  ChannelType::hValues_optional& ChannelType::
  hValues ()
  {
    return this->hValues_;
  }

  void ChannelType::
  hValues (const hValues_type& x)
  {
    this->hValues_.set (x);
  }

  void ChannelType::
  hValues (const hValues_optional& x)
  {
    this->hValues_ = x;
  }

  const ChannelType::producer_type& ChannelType::
  producer () const
  {
    return this->producer_.get ();
  }

  ChannelType::producer_type& ChannelType::
  producer ()
  {
    return this->producer_.get ();
  }

  void ChannelType::
  producer (const producer_type& x)
  {
    this->producer_.set (x);
  }

  void ChannelType::
  producer (::std::auto_ptr< producer_type > x)
  {
    this->producer_.set (x);
  }

  const ChannelType::consumer_type& ChannelType::
  consumer () const
  {
    return this->consumer_.get ();
  }

  ChannelType::consumer_type& ChannelType::
  consumer ()
  {
    return this->consumer_.get ();
  }

  void ChannelType::
  consumer (const consumer_type& x)
  {
    this->consumer_.set (x);
  }

  void ChannelType::
  consumer (::std::auto_ptr< consumer_type > x)
  {
    this->consumer_.set (x);
  }


  // CallType
  // 

  const CallType::calls_optional& CallType::
  calls () const
  {
    return this->calls_;
  }

  CallType::calls_optional& CallType::
  calls ()
  {
    return this->calls_;
  }

  void CallType::
  calls (const calls_type& x)
  {
    this->calls_.set (x);
  }

  void CallType::
  calls (const calls_optional& x)
  {
    this->calls_ = x;
  }

  const CallType::contribution_optional& CallType::
  contribution () const
  {
    return this->contribution_;
  }

  CallType::contribution_optional& CallType::
  contribution ()
  {
    return this->contribution_;
  }

  void CallType::
  contribution (const contribution_type& x)
  {
    this->contribution_.set (x);
  }

  void CallType::
  contribution (const contribution_optional& x)
  {
    this->contribution_ = x;
  }

  const CallType::caller_type& CallType::
  caller () const
  {
    return this->caller_.get ();
  }

  CallType::caller_type& CallType::
  caller ()
  {
    return this->caller_.get ();
  }

  void CallType::
  caller (const caller_type& x)
  {
    this->caller_.set (x);
  }

  void CallType::
  caller (::std::auto_ptr< caller_type > x)
  {
    this->caller_.set (x);
  }

  const CallType::callee_type& CallType::
  callee () const
  {
    return this->callee_.get ();
  }

  CallType::callee_type& CallType::
  callee ()
  {
    return this->callee_.get ();
  }

  void CallType::
  callee (const callee_type& x)
  {
    this->callee_.set (x);
  }

  void CallType::
  callee (::std::auto_ptr< callee_type > x)
  {
    this->callee_.set (x);
  }


  // TargetType
  // 

  const TargetType::measurement_sequence& TargetType::
  measurement () const
  {
    return this->measurement_;
  }

  TargetType::measurement_sequence& TargetType::
  measurement ()
  {
    return this->measurement_;
  }

  void TargetType::
  measurement (const measurement_sequence& s)
  {
    this->measurement_ = s;
  }

  const TargetType::name_type& TargetType::
  name () const
  {
    return this->name_.get ();
  }

  TargetType::name_type& TargetType::
  name ()
  {
    return this->name_.get ();
  }

  void TargetType::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void TargetType::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }


  // ApplicationType
  // 

  const ApplicationType::location_type& ApplicationType::
  location () const
  {
    return this->location_.get ();
  }

  ApplicationType::location_type& ApplicationType::
  location ()
  {
    return this->location_.get ();
  }

  void ApplicationType::
  location (const location_type& x)
  {
    this->location_.set (x);
  }

  void ApplicationType::
  location (::std::auto_ptr< location_type > x)
  {
    this->location_.set (x);
  }

  const ApplicationType::workdir_type& ApplicationType::
  workdir () const
  {
    return this->workdir_.get ();
  }

  ApplicationType::workdir_type& ApplicationType::
  workdir ()
  {
    return this->workdir_.get ();
  }

  void ApplicationType::
  workdir (const workdir_type& x)
  {
    this->workdir_.set (x);
  }

  void ApplicationType::
  workdir (::std::auto_ptr< workdir_type > x)
  {
    this->workdir_.set (x);
  }

  const ApplicationType::arguments_type& ApplicationType::
  arguments () const
  {
    return this->arguments_.get ();
  }

  ApplicationType::arguments_type& ApplicationType::
  arguments ()
  {
    return this->arguments_.get ();
  }

  void ApplicationType::
  arguments (const arguments_type& x)
  {
    this->arguments_.set (x);
  }

  void ApplicationType::
  arguments (::std::auto_ptr< arguments_type > x)
  {
    this->arguments_.set (x);
  }

  const ApplicationType::date_type& ApplicationType::
  date () const
  {
    return this->date_.get ();
  }

  ApplicationType::date_type& ApplicationType::
  date ()
  {
    return this->date_.get ();
  }

  void ApplicationType::
  date (const date_type& x)
  {
    this->date_.set (x);
  }

  void ApplicationType::
  date (::std::auto_ptr< date_type > x)
  {
    this->date_.set (x);
  }

  const ApplicationType::functions_type& ApplicationType::
  functions () const
  {
    return this->functions_.get ();
  }

  ApplicationType::functions_type& ApplicationType::
  functions ()
  {
    return this->functions_.get ();
  }

  void ApplicationType::
  functions (const functions_type& x)
  {
    this->functions_.set (x);
  }

  void ApplicationType::
  functions (::std::auto_ptr< functions_type > x)
  {
    this->functions_.set (x);
  }

  const ApplicationType::QDUGraph_type& ApplicationType::
  QDUGraph () const
  {
    return this->QDUGraph_.get ();
  }

  ApplicationType::QDUGraph_type& ApplicationType::
  QDUGraph ()
  {
    return this->QDUGraph_.get ();
  }

  void ApplicationType::
  QDUGraph (const QDUGraph_type& x)
  {
    this->QDUGraph_.set (x);
  }

  void ApplicationType::
  QDUGraph (::std::auto_ptr< QDUGraph_type > x)
  {
    this->QDUGraph_.set (x);
  }

  const ApplicationType::CallGraph_type& ApplicationType::
  CallGraph () const
  {
    return this->CallGraph_.get ();
  }

  ApplicationType::CallGraph_type& ApplicationType::
  CallGraph ()
  {
    return this->CallGraph_.get ();
  }

  void ApplicationType::
  CallGraph (const CallGraph_type& x)
  {
    this->CallGraph_.set (x);
  }

  void ApplicationType::
  CallGraph (::std::auto_ptr< CallGraph_type > x)
  {
    this->CallGraph_.set (x);
  }

  const ApplicationType::name_type& ApplicationType::
  name () const
  {
    return this->name_.get ();
  }

  ApplicationType::name_type& ApplicationType::
  name ()
  {
    return this->name_.get ();
  }

  void ApplicationType::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void ApplicationType::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const ApplicationType::category_optional& ApplicationType::
  category () const
  {
    return this->category_;
  }

  ApplicationType::category_optional& ApplicationType::
  category ()
  {
    return this->category_;
  }

  void ApplicationType::
  category (const category_type& x)
  {
    this->category_.set (x);
  }

  void ApplicationType::
  category (const category_optional& x)
  {
    this->category_ = x;
  }

  void ApplicationType::
  category (::std::auto_ptr< category_type > x)
  {
    this->category_.set (x);
  }


  // ProfilesType
  // 

  const ProfilesType::application_sequence& ProfilesType::
  application () const
  {
    return this->application_;
  }

  ProfilesType::application_sequence& ProfilesType::
  application ()
  {
    return this->application_;
  }

  void ProfilesType::
  application (const application_sequence& s)
  {
    this->application_ = s;
  }


  // metrics
  // 

  const metrics::metric_sequence& metrics::
  metric () const
  {
    return this->metric_;
  }

  metrics::metric_sequence& metrics::
  metric ()
  {
    return this->metric_;
  }

  void metrics::
  metric (const metric_sequence& s)
  {
    this->metric_ = s;
  }


  // statistics
  // 

  const statistics::measurement_sequence& statistics::
  measurement () const
  {
    return this->measurement_;
  }

  statistics::measurement_sequence& statistics::
  measurement ()
  {
    return this->measurement_;
  }

  void statistics::
  measurement (const measurement_sequence& s)
  {
    this->measurement_ = s;
  }

  const statistics::target_sequence& statistics::
  target () const
  {
    return this->target_;
  }

  statistics::target_sequence& statistics::
  target ()
  {
    return this->target_;
  }

  void statistics::
  target (const target_sequence& s)
  {
    this->target_ = s;
  }


  // functions
  // 

  const functions::function_sequence& functions::
  function () const
  {
    return this->function_;
  }

  functions::function_sequence& functions::
  function ()
  {
    return this->function_;
  }

  void functions::
  function (const function_sequence& s)
  {
    this->function_ = s;
  }


  // QDUGraph
  // 

  const QDUGraph::channel_sequence& QDUGraph::
  channel () const
  {
    return this->channel_;
  }

  QDUGraph::channel_sequence& QDUGraph::
  channel ()
  {
    return this->channel_;
  }

  void QDUGraph::
  channel (const channel_sequence& s)
  {
    this->channel_ = s;
  }


  // CallGraph
  // 

  const CallGraph::call_sequence& CallGraph::
  call () const
  {
    return this->call_;
  }

  CallGraph::call_sequence& CallGraph::
  call ()
  {
    return this->call_;
  }

  void CallGraph::
  call (const call_sequence& s)
  {
    this->call_ = s;
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace q2profiling
{
  // FunctionType
  //

  FunctionType::
  FunctionType (const metrics_type& metrics,
                const statistics_type& statistics,
                const name_type& name)
  : ::xml_schema::type (),
    metrics_ (metrics, ::xml_schema::flags (), this),
    statistics_ (statistics, ::xml_schema::flags (), this),
    name_ (name, ::xml_schema::flags (), this)
  {
  }

  FunctionType::
  FunctionType (::std::auto_ptr< metrics_type >& metrics,
                ::std::auto_ptr< statistics_type >& statistics,
                const name_type& name)
  : ::xml_schema::type (),
    metrics_ (metrics, ::xml_schema::flags (), this),
    statistics_ (statistics, ::xml_schema::flags (), this),
    name_ (name, ::xml_schema::flags (), this)
  {
  }

  FunctionType::
  FunctionType (const FunctionType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    metrics_ (x.metrics_, f, this),
    statistics_ (x.statistics_, f, this),
    name_ (x.name_, f, this)
  {
  }

  FunctionType::
  FunctionType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    metrics_ (f, this),
    statistics_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void FunctionType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // metrics
      //
      if (n.name () == "metrics" && n.namespace_ () == "http://www.example.org/q2profiling")
      {
        ::std::auto_ptr< metrics_type > r (
          metrics_traits::create (i, f, this));

        if (!metrics_.present ())
        {
          this->metrics_.set (r);
          continue;
        }
      }

      // statistics
      //
      if (n.name () == "statistics" && n.namespace_ () == "http://www.example.org/q2profiling")
      {
        ::std::auto_ptr< statistics_type > r (
          statistics_traits::create (i, f, this));

        if (!statistics_.present ())
        {
          this->statistics_.set (r);
          continue;
        }
      }

      break;
    }

    if (!metrics_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "metrics",
        "http://www.example.org/q2profiling");
    }

    if (!statistics_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "statistics",
        "http://www.example.org/q2profiling");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  FunctionType* FunctionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FunctionType (*this, f, c);
  }

  FunctionType::
  ~FunctionType ()
  {
  }

  // MetricType
  //

  MetricType::
  MetricType (const ::xml_schema::double_& _xsd_double__base,
              const name_type& name,
              const type_type& type)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base),
    name_ (name, ::xml_schema::flags (), this),
    type_ (type, ::xml_schema::flags (), this)
  {
  }

  MetricType::
  MetricType (const MetricType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c),
    name_ (x.name_, f, this),
    type_ (x.type_, f, this)
  {
  }

  MetricType::
  MetricType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f | ::xml_schema::flags::base, c),
    name_ (f, this),
    type_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void MetricType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  MetricType* MetricType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MetricType (*this, f, c);
  }

  MetricType::
  ~MetricType ()
  {
  }

  // MeasurementType
  //

  MeasurementType::
  MeasurementType (const ::xml_schema::double_& _xsd_double__base,
                   const name_type& name,
                   const type_type& type,
                   const by_type& by)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base),
    unit_ (::xml_schema::flags (), this),
    name_ (name, ::xml_schema::flags (), this),
    type_ (type, ::xml_schema::flags (), this),
    by_ (by, ::xml_schema::flags (), this)
  {
  }

  MeasurementType::
  MeasurementType (const MeasurementType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c),
    unit_ (x.unit_, f, this),
    name_ (x.name_, f, this),
    type_ (x.type_, f, this),
    by_ (x.by_, f, this)
  {
  }

  MeasurementType::
  MeasurementType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f | ::xml_schema::flags::base, c),
    unit_ (f, this),
    name_ (f, this),
    type_ (f, this),
    by_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void MeasurementType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "unit" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< unit_type > r (
          unit_traits::create (i, f, this));

        this->unit_.set (r);
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        this->type_.set (r);
        continue;
      }

      if (n.name () == "by" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< by_type > r (
          by_traits::create (i, f, this));

        this->by_.set (r);
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }

    if (!by_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "by",
        "");
    }
  }

  MeasurementType* MeasurementType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MeasurementType (*this, f, c);
  }

  MeasurementType::
  ~MeasurementType ()
  {
  }

  // ChannelType
  //

  ChannelType::
  ChannelType (const producer_type& producer,
               const consumer_type& consumer)
  : ::xml_schema::type (),
    UnMA_ (::xml_schema::flags (), this),
    hUnMA_ (::xml_schema::flags (), this),
    bytes_ (::xml_schema::flags (), this),
    hBytes_ (::xml_schema::flags (), this),
    Values_ (::xml_schema::flags (), this),
    hValues_ (::xml_schema::flags (), this),
    producer_ (producer, ::xml_schema::flags (), this),
    consumer_ (consumer, ::xml_schema::flags (), this)
  {
  }

  ChannelType::
  ChannelType (const ChannelType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    UnMA_ (x.UnMA_, f, this),
    hUnMA_ (x.hUnMA_, f, this),
    bytes_ (x.bytes_, f, this),
    hBytes_ (x.hBytes_, f, this),
    Values_ (x.Values_, f, this),
    hValues_ (x.hValues_, f, this),
    producer_ (x.producer_, f, this),
    consumer_ (x.consumer_, f, this)
  {
  }

  ChannelType::
  ChannelType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    UnMA_ (f, this),
    hUnMA_ (f, this),
    bytes_ (f, this),
    hBytes_ (f, this),
    Values_ (f, this),
    hValues_ (f, this),
    producer_ (f, this),
    consumer_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void ChannelType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // UnMA
      //
      if (n.name () == "UnMA" && n.namespace_ () == "http://www.example.org/q2profiling")
      {
        if (!this->UnMA_)
        {
          this->UnMA_.set (UnMA_traits::create (i, f, this));
          continue;
        }
      }

      // hUnMA
      //
      if (n.name () == "hUnMA" && n.namespace_ () == "http://www.example.org/q2profiling")
      {
        if (!this->hUnMA_)
        {
          this->hUnMA_.set (hUnMA_traits::create (i, f, this));
          continue;
        }
      }

      // bytes
      //
      if (n.name () == "bytes" && n.namespace_ () == "http://www.example.org/q2profiling")
      {
        if (!this->bytes_)
        {
          this->bytes_.set (bytes_traits::create (i, f, this));
          continue;
        }
      }

      // hBytes
      //
      if (n.name () == "hBytes" && n.namespace_ () == "http://www.example.org/q2profiling")
      {
        if (!this->hBytes_)
        {
          this->hBytes_.set (hBytes_traits::create (i, f, this));
          continue;
        }
      }

      // Values
      //
      if (n.name () == "Values" && n.namespace_ () == "http://www.example.org/q2profiling")
      {
        if (!this->Values_)
        {
          this->Values_.set (Values_traits::create (i, f, this));
          continue;
        }
      }

      // hValues
      //
      if (n.name () == "hValues" && n.namespace_ () == "http://www.example.org/q2profiling")
      {
        if (!this->hValues_)
        {
          this->hValues_.set (hValues_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "producer" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< producer_type > r (
          producer_traits::create (i, f, this));

        this->producer_.set (r);
        continue;
      }

      if (n.name () == "consumer" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< consumer_type > r (
          consumer_traits::create (i, f, this));

        this->consumer_.set (r);
        continue;
      }
    }

    if (!producer_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "producer",
        "");
    }

    if (!consumer_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "consumer",
        "");
    }
  }

  ChannelType* ChannelType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ChannelType (*this, f, c);
  }

  ChannelType::
  ~ChannelType ()
  {
  }

  // CallType
  //

  CallType::
  CallType (const caller_type& caller,
            const callee_type& callee)
  : ::xml_schema::type (),
    calls_ (::xml_schema::flags (), this),
    contribution_ (::xml_schema::flags (), this),
    caller_ (caller, ::xml_schema::flags (), this),
    callee_ (callee, ::xml_schema::flags (), this)
  {
  }

  CallType::
  CallType (const CallType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    calls_ (x.calls_, f, this),
    contribution_ (x.contribution_, f, this),
    caller_ (x.caller_, f, this),
    callee_ (x.callee_, f, this)
  {
  }

  CallType::
  CallType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    calls_ (f, this),
    contribution_ (f, this),
    caller_ (f, this),
    callee_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void CallType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // calls
      //
      if (n.name () == "calls" && n.namespace_ () == "http://www.example.org/q2profiling")
      {
        if (!this->calls_)
        {
          this->calls_.set (calls_traits::create (i, f, this));
          continue;
        }
      }

      // contribution
      //
      if (n.name () == "contribution" && n.namespace_ () == "http://www.example.org/q2profiling")
      {
        if (!this->contribution_)
        {
          this->contribution_.set (contribution_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "caller" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< caller_type > r (
          caller_traits::create (i, f, this));

        this->caller_.set (r);
        continue;
      }

      if (n.name () == "callee" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< callee_type > r (
          callee_traits::create (i, f, this));

        this->callee_.set (r);
        continue;
      }
    }

    if (!caller_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "caller",
        "");
    }

    if (!callee_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "callee",
        "");
    }
  }

  CallType* CallType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CallType (*this, f, c);
  }

  CallType::
  ~CallType ()
  {
  }

  // TargetType
  //

  TargetType::
  TargetType (const name_type& name)
  : ::xml_schema::type (),
    measurement_ (::xml_schema::flags (), this),
    name_ (name, ::xml_schema::flags (), this)
  {
  }

  TargetType::
  TargetType (const TargetType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    measurement_ (x.measurement_, f, this),
    name_ (x.name_, f, this)
  {
  }

  TargetType::
  TargetType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    measurement_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void TargetType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // measurement
      //
      if (n.name () == "measurement" && n.namespace_ () == "http://www.example.org/q2profiling")
      {
        ::std::auto_ptr< measurement_type > r (
          measurement_traits::create (i, f, this));

        this->measurement_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  TargetType* TargetType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TargetType (*this, f, c);
  }

  TargetType::
  ~TargetType ()
  {
  }

  // ApplicationType
  //

  ApplicationType::
  ApplicationType (const location_type& location,
                   const workdir_type& workdir,
                   const arguments_type& arguments,
                   const date_type& date,
                   const functions_type& functions,
                   const QDUGraph_type& QDUGraph,
                   const CallGraph_type& CallGraph,
                   const name_type& name)
  : ::xml_schema::type (),
    location_ (location, ::xml_schema::flags (), this),
    workdir_ (workdir, ::xml_schema::flags (), this),
    arguments_ (arguments, ::xml_schema::flags (), this),
    date_ (date, ::xml_schema::flags (), this),
    functions_ (functions, ::xml_schema::flags (), this),
    QDUGraph_ (QDUGraph, ::xml_schema::flags (), this),
    CallGraph_ (CallGraph, ::xml_schema::flags (), this),
    name_ (name, ::xml_schema::flags (), this),
    category_ (::xml_schema::flags (), this)
  {
  }

  ApplicationType::
  ApplicationType (const location_type& location,
                   const workdir_type& workdir,
                   const arguments_type& arguments,
                   const date_type& date,
                   ::std::auto_ptr< functions_type >& functions,
                   ::std::auto_ptr< QDUGraph_type >& QDUGraph,
                   ::std::auto_ptr< CallGraph_type >& CallGraph,
                   const name_type& name)
  : ::xml_schema::type (),
    location_ (location, ::xml_schema::flags (), this),
    workdir_ (workdir, ::xml_schema::flags (), this),
    arguments_ (arguments, ::xml_schema::flags (), this),
    date_ (date, ::xml_schema::flags (), this),
    functions_ (functions, ::xml_schema::flags (), this),
    QDUGraph_ (QDUGraph, ::xml_schema::flags (), this),
    CallGraph_ (CallGraph, ::xml_schema::flags (), this),
    name_ (name, ::xml_schema::flags (), this),
    category_ (::xml_schema::flags (), this)
  {
  }

  ApplicationType::
  ApplicationType (const ApplicationType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    location_ (x.location_, f, this),
    workdir_ (x.workdir_, f, this),
    arguments_ (x.arguments_, f, this),
    date_ (x.date_, f, this),
    functions_ (x.functions_, f, this),
    QDUGraph_ (x.QDUGraph_, f, this),
    CallGraph_ (x.CallGraph_, f, this),
    name_ (x.name_, f, this),
    category_ (x.category_, f, this)
  {
  }

  ApplicationType::
  ApplicationType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    location_ (f, this),
    workdir_ (f, this),
    arguments_ (f, this),
    date_ (f, this),
    functions_ (f, this),
    QDUGraph_ (f, this),
    CallGraph_ (f, this),
    name_ (f, this),
    category_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void ApplicationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // location
      //
      if (n.name () == "location" && n.namespace_ () == "http://www.example.org/q2profiling")
      {
        ::std::auto_ptr< location_type > r (
          location_traits::create (i, f, this));

        if (!location_.present ())
        {
          this->location_.set (r);
          continue;
        }
      }

      // workdir
      //
      if (n.name () == "workdir" && n.namespace_ () == "http://www.example.org/q2profiling")
      {
        ::std::auto_ptr< workdir_type > r (
          workdir_traits::create (i, f, this));

        if (!workdir_.present ())
        {
          this->workdir_.set (r);
          continue;
        }
      }

      // arguments
      //
      if (n.name () == "arguments" && n.namespace_ () == "http://www.example.org/q2profiling")
      {
        ::std::auto_ptr< arguments_type > r (
          arguments_traits::create (i, f, this));

        if (!arguments_.present ())
        {
          this->arguments_.set (r);
          continue;
        }
      }

      // date
      //
      if (n.name () == "date" && n.namespace_ () == "http://www.example.org/q2profiling")
      {
        ::std::auto_ptr< date_type > r (
          date_traits::create (i, f, this));

        if (!date_.present ())
        {
          this->date_.set (r);
          continue;
        }
      }

      // functions
      //
      if (n.name () == "functions" && n.namespace_ () == "http://www.example.org/q2profiling")
      {
        ::std::auto_ptr< functions_type > r (
          functions_traits::create (i, f, this));

        if (!functions_.present ())
        {
          this->functions_.set (r);
          continue;
        }
      }

      // QDUGraph
      //
      if (n.name () == "QDUGraph" && n.namespace_ () == "http://www.example.org/q2profiling")
      {
        ::std::auto_ptr< QDUGraph_type > r (
          QDUGraph_traits::create (i, f, this));

        if (!QDUGraph_.present ())
        {
          this->QDUGraph_.set (r);
          continue;
        }
      }

      // CallGraph
      //
      if (n.name () == "CallGraph" && n.namespace_ () == "http://www.example.org/q2profiling")
      {
        ::std::auto_ptr< CallGraph_type > r (
          CallGraph_traits::create (i, f, this));

        if (!CallGraph_.present ())
        {
          this->CallGraph_.set (r);
          continue;
        }
      }

      break;
    }

    if (!location_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "location",
        "http://www.example.org/q2profiling");
    }

    if (!workdir_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "workdir",
        "http://www.example.org/q2profiling");
    }

    if (!arguments_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "arguments",
        "http://www.example.org/q2profiling");
    }

    if (!date_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "date",
        "http://www.example.org/q2profiling");
    }

    if (!functions_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "functions",
        "http://www.example.org/q2profiling");
    }

    if (!QDUGraph_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "QDUGraph",
        "http://www.example.org/q2profiling");
    }

    if (!CallGraph_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CallGraph",
        "http://www.example.org/q2profiling");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        this->name_.set (r);
        continue;
      }

      if (n.name () == "category" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< category_type > r (
          category_traits::create (i, f, this));

        this->category_.set (r);
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  ApplicationType* ApplicationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ApplicationType (*this, f, c);
  }

  ApplicationType::
  ~ApplicationType ()
  {
  }

  // ProfilesType
  //

  ProfilesType::
  ProfilesType ()
  : ::xml_schema::type (),
    application_ (::xml_schema::flags (), this)
  {
  }

  ProfilesType::
  ProfilesType (const ProfilesType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    application_ (x.application_, f, this)
  {
  }

  ProfilesType::
  ProfilesType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    application_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ProfilesType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // application
      //
      if (n.name () == "application" && n.namespace_ () == "http://www.example.org/q2profiling")
      {
        ::std::auto_ptr< application_type > r (
          application_traits::create (i, f, this));

        this->application_.push_back (r);
        continue;
      }

      break;
    }
  }

  ProfilesType* ProfilesType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ProfilesType (*this, f, c);
  }

  ProfilesType::
  ~ProfilesType ()
  {
  }

  // metrics
  //

  metrics::
  metrics ()
  : ::xml_schema::type (),
    metric_ (::xml_schema::flags (), this)
  {
  }

  metrics::
  metrics (const metrics& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    metric_ (x.metric_, f, this)
  {
  }

  metrics::
  metrics (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    metric_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void metrics::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // metric
      //
      if (n.name () == "metric" && n.namespace_ () == "http://www.example.org/q2profiling")
      {
        ::std::auto_ptr< metric_type > r (
          metric_traits::create (i, f, this));

        this->metric_.push_back (r);
        continue;
      }

      break;
    }
  }

  metrics* metrics::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class metrics (*this, f, c);
  }

  metrics::
  ~metrics ()
  {
  }

  // statistics
  //

  statistics::
  statistics ()
  : ::xml_schema::type (),
    measurement_ (::xml_schema::flags (), this),
    target_ (::xml_schema::flags (), this)
  {
  }

  statistics::
  statistics (const statistics& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    measurement_ (x.measurement_, f, this),
    target_ (x.target_, f, this)
  {
  }

  statistics::
  statistics (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    measurement_ (f, this),
    target_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void statistics::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // measurement
      //
      if (n.name () == "measurement" && n.namespace_ () == "http://www.example.org/q2profiling")
      {
        ::std::auto_ptr< measurement_type > r (
          measurement_traits::create (i, f, this));

        this->measurement_.push_back (r);
        continue;
      }

      // target
      //
      if (n.name () == "target" && n.namespace_ () == "http://www.example.org/q2profiling")
      {
        ::std::auto_ptr< target_type > r (
          target_traits::create (i, f, this));

        this->target_.push_back (r);
        continue;
      }

      break;
    }
  }

  statistics* statistics::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class statistics (*this, f, c);
  }

  statistics::
  ~statistics ()
  {
  }

  // functions
  //

  functions::
  functions ()
  : ::xml_schema::type (),
    function_ (::xml_schema::flags (), this)
  {
  }

  functions::
  functions (const functions& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    function_ (x.function_, f, this)
  {
  }

  functions::
  functions (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    function_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void functions::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // function
      //
      if (n.name () == "function" && n.namespace_ () == "http://www.example.org/q2profiling")
      {
        ::std::auto_ptr< function_type > r (
          function_traits::create (i, f, this));

        this->function_.push_back (r);
        continue;
      }

      break;
    }
  }

  functions* functions::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class functions (*this, f, c);
  }

  functions::
  ~functions ()
  {
  }

  // QDUGraph
  //

  QDUGraph::
  QDUGraph ()
  : ::xml_schema::type (),
    channel_ (::xml_schema::flags (), this)
  {
  }

  QDUGraph::
  QDUGraph (const QDUGraph& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    channel_ (x.channel_, f, this)
  {
  }

  QDUGraph::
  QDUGraph (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    channel_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void QDUGraph::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // channel
      //
      if (n.name () == "channel" && n.namespace_ () == "http://www.example.org/q2profiling")
      {
        ::std::auto_ptr< channel_type > r (
          channel_traits::create (i, f, this));

        this->channel_.push_back (r);
        continue;
      }

      break;
    }
  }

  QDUGraph* QDUGraph::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class QDUGraph (*this, f, c);
  }

  QDUGraph::
  ~QDUGraph ()
  {
  }

  // CallGraph
  //

  CallGraph::
  CallGraph ()
  : ::xml_schema::type (),
    call_ (::xml_schema::flags (), this)
  {
  }

  CallGraph::
  CallGraph (const CallGraph& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    call_ (x.call_, f, this)
  {
  }

  CallGraph::
  CallGraph (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    call_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void CallGraph::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // call
      //
      if (n.name () == "call" && n.namespace_ () == "http://www.example.org/q2profiling")
      {
        ::std::auto_ptr< call_type > r (
          call_traits::create (i, f, this));

        this->call_.push_back (r);
        continue;
      }

      break;
    }
  }

  CallGraph* CallGraph::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CallGraph (*this, f, c);
  }

  CallGraph::
  ~CallGraph ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace q2profiling
{
  ::std::auto_ptr< ::q2profiling::ProfilesType >
  profiles (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::q2profiling::ProfilesType > r (
      ::q2profiling::profiles (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::q2profiling::ProfilesType >
  profiles (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::q2profiling::ProfilesType > r (
      ::q2profiling::profiles (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::q2profiling::ProfilesType >
  profiles (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::q2profiling::ProfilesType > r (
      ::q2profiling::profiles (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::q2profiling::ProfilesType >
  profiles (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::q2profiling::profiles (isrc, f, p);
  }

  ::std::auto_ptr< ::q2profiling::ProfilesType >
  profiles (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::q2profiling::profiles (isrc, h, f, p);
  }

  ::std::auto_ptr< ::q2profiling::ProfilesType >
  profiles (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::q2profiling::profiles (isrc, h, f, p);
  }

  ::std::auto_ptr< ::q2profiling::ProfilesType >
  profiles (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::q2profiling::profiles (isrc, f, p);
  }

  ::std::auto_ptr< ::q2profiling::ProfilesType >
  profiles (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::q2profiling::profiles (isrc, h, f, p);
  }

  ::std::auto_ptr< ::q2profiling::ProfilesType >
  profiles (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::q2profiling::profiles (isrc, h, f, p);
  }

  ::std::auto_ptr< ::q2profiling::ProfilesType >
  profiles (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::q2profiling::ProfilesType > r (
      ::q2profiling::profiles (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::q2profiling::ProfilesType >
  profiles (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::q2profiling::ProfilesType > r (
      ::q2profiling::profiles (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::q2profiling::ProfilesType >
  profiles (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::q2profiling::ProfilesType > r (
      ::q2profiling::profiles (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::q2profiling::ProfilesType >
  profiles (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::q2profiling::ProfilesType > r (
        ::q2profiling::profiles (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "profiles" &&
        n.namespace_ () == "http://www.example.org/q2profiling")
    {
      ::std::auto_ptr< ::q2profiling::ProfilesType > r (
        ::xsd::cxx::tree::traits< ::q2profiling::ProfilesType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "profiles",
      "http://www.example.org/q2profiling");
  }

  ::std::auto_ptr< ::q2profiling::ProfilesType >
  profiles (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "profiles" &&
        n.namespace_ () == "http://www.example.org/q2profiling")
    {
      ::std::auto_ptr< ::q2profiling::ProfilesType > r (
        ::xsd::cxx::tree::traits< ::q2profiling::ProfilesType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "profiles",
      "http://www.example.org/q2profiling");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

